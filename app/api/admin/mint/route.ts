import { NextRequest, NextResponse } from 'next/server';
import { query } from '@/lib/database';
import { ApiResponse } from '@/types/api';

// POST /api/admin/mint - Mint new bond token and create market (Admin only)
export async function POST(request: NextRequest) {
  try {
    // Admin authentication
    const authHeader = request.headers.get('authorization');
    if (!authHeader || !authHeader.includes(process.env.ADMIN_API_KEY || '')) {
      return NextResponse.json(
        { success: false, error: 'Unauthorized' } as ApiResponse,
        { status: 401 }
      );
    }

    const {
      // Bond parameters
      issuer,
      name,
      coupon_rate,
      maturity_date,
      face_value,
      total_supply,
      credit_rating,
      credit_rating_agency,
      sector,
      interest_payment_frequency,
      listed_yield,
      min_investment,
      logo_url,
      isin,
      
      // Market parameters
      initial_price_scaled,
      admin_pubkey,
      
      // Blockchain parameters (would be generated by Anchor program)
      bond_mint_address,
      market_pda,
      vault_bond_account,
      vault_usdc_account
    } = await request.json();

    // Validate required fields
    const requiredFields = {
      issuer, name, coupon_rate, maturity_date, face_value, total_supply,
      initial_price_scaled, admin_pubkey
    };

    for (const [field, value] of Object.entries(requiredFields)) {
      if (!value) {
        return NextResponse.json(
          { success: false, error: `Missing required field: ${field}` } as ApiResponse,
          { status: 400 }
        );
      }
    }

    // For demo purposes, generate mock blockchain addresses if not provided
    const bondMint = bond_mint_address || generateMockSolanaAddress();
    const marketPDA = market_pda || generateMockSolanaAddress();
    const vaultBond = vault_bond_account || generateMockSolanaAddress();
    const vaultUsdc = vault_usdc_account || generateMockSolanaAddress();

    // Start transaction
    await query('BEGIN');

    try {
      // 1. Create bond record
      const bondResult = await query(`
        INSERT INTO bonds (
          bond_mint, isin, issuer, name, coupon_rate, maturity_date, 
          face_value, decimals, total_supply, credit_rating, 
          credit_rating_agency, sector, interest_payment_frequency, 
          listed_yield, min_investment, logo_url
        ) VALUES (
          $1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13, $14, $15, $16
        ) RETURNING *
      `, [
        bondMint, isin, issuer, name, coupon_rate, maturity_date,
        face_value, 6, total_supply, credit_rating,
        credit_rating_agency, sector, interest_payment_frequency || 'monthly',
        listed_yield, min_investment, logo_url
      ]);

      const bond = bondResult.rows[0];

      // 2. Create market record
      const marketResult = await query(`
        INSERT INTO markets (
          bond_id, market_pda, price_per_token_scaled, 
          vault_bond_account, vault_usdc_account, admin_pubkey,
          usdc_mint, liquidity_bond, liquidity_usdc
        ) VALUES (
          $1, $2, $3, $4, $5, $6, $7, $8, $9
        ) RETURNING *
      `, [
        bond.id, marketPDA, initial_price_scaled,
        vaultBond, vaultUsdc, admin_pubkey,
        process.env.USDC_MINT_ADDRESS || '4zMMC9srt5Ri5X14GAgXhaHii3GnPAEERYPJgZJDncDU',
        total_supply, // Initial bond liquidity
        0 // Initial USDC liquidity
      ]);

      const market = marketResult.rows[0];

      // 3. Create initial price history entry
      await query(`
        INSERT INTO price_history (market_id, price_scaled, source, volume_24h)
        VALUES ($1, $2, 'manual', 0)
      `, [market.id, initial_price_scaled]);

      // 4. Log system events
      await query(`
        INSERT INTO system_events (event_type, entity_id, data) 
        VALUES ('bond_mint', $1, $2)
      `, [bond.id.toString(), JSON.stringify(bond)]);

      await query(`
        INSERT INTO system_events (event_type, entity_id, data) 
        VALUES ('market_init', $1, $2)
      `, [market.id.toString(), JSON.stringify(market)]);

      // Commit transaction
      await query('COMMIT');

      // In a real implementation, this would trigger:
      // 1. Solana SPL token minting
      // 2. Anchor program market initialization
      // 3. Initial liquidity provision

      const response = {
        bond,
        market,
        blockchain_info: {
          bond_mint: bondMint,
          market_pda: marketPDA,
          vault_bond_account: vaultBond,
          vault_usdc_account: vaultUsdc,
          usdc_mint: process.env.USDC_MINT_ADDRESS
        },
        next_steps: [
          'Deploy SPL token with mint authority',
          'Initialize Anchor market program',
          'Fund vault accounts with initial liquidity',
          'Set up oracle price feeds'
        ]
      };

      return NextResponse.json({
        success: true,
        data: response,
        message: 'Bond and market created successfully'
      } as ApiResponse);

    } catch (error) {
      // Rollback transaction
      await query('ROLLBACK');
      throw error;
    }

  } catch (error) {
    console.error('Error in mint operation:', error);
    return NextResponse.json(
      { success: false, error: 'Failed to mint bond and create market' } as ApiResponse,
      { status: 500 }
    );
  }
}

// Generate mock Solana addresses for demo purposes
function generateMockSolanaAddress(): string {
  const chars = 'ABCDEFGHJKMNPQRSTUVWXYZabcdefghjkmnpqrstuvwxyz123456789';
  let result = '';
  for (let i = 0; i < 44; i++) {
    result += chars.charAt(Math.floor(Math.random() * chars.length));
  }
  return result;
}

// GET /api/admin/mint - Get mint operations history
export async function GET(request: NextRequest) {
  try {
    // Admin authentication
    const authHeader = request.headers.get('authorization');
    if (!authHeader || !authHeader.includes(process.env.ADMIN_API_KEY || '')) {
      return NextResponse.json(
        { success: false, error: 'Unauthorized' } as ApiResponse,
        { status: 401 }
      );
    }

    const { searchParams } = new URL(request.url);
    const limit = parseInt(searchParams.get('limit') || '20');
    const offset = parseInt(searchParams.get('offset') || '0');

    // Get recent mint operations
    const result = await query(`
      SELECT 
        se.id,
        se.event_type,
        se.entity_id,
        se.data,
        se.created_at,
        b.name as bond_name,
        b.issuer,
        b.bond_mint,
        m.market_pda,
        m.price_per_token_scaled as initial_price
      FROM system_events se
      LEFT JOIN bonds b ON se.entity_id = b.id::text
      LEFT JOIN markets m ON b.id = m.bond_id
      WHERE se.event_type IN ('bond_mint', 'market_init')
      ORDER BY se.created_at DESC
      LIMIT $1 OFFSET $2
    `, [limit, offset]);

    return NextResponse.json({
      success: true,
      data: result.rows
    } as ApiResponse);

  } catch (error) {
    console.error('Error fetching mint history:', error);
    return NextResponse.json(
      { success: false, error: 'Failed to fetch mint history' } as ApiResponse,
      { status: 500 }
    );
  }
}
